%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ast.h"
#include "parser.tab.h"  /* Generated by yacc/bison */

/* Track line and column for error reporting */
int line = 1;
int column = 1;

void update_position() {
    column += yyleng;
}

void new_line() {
    line++;
    column = 1;
}

char* process_string();  /* Function to handle string escapes */
%}

%option noyywrap
%option yylineno

%%
"{"         { update_position(); return LBRACE; }
"}"         { update_position(); return RBRACE; }
"["         { update_position(); return LBRACKET; }
"]"         { update_position(); return RBRACKET; }
":"         { update_position(); return COLON; }
","         { update_position(); return COMMA; }
"true"      { update_position(); yylval.boolean_val = 1; return TRUE; }
"false"     { update_position(); yylval.boolean_val = 0; return FALSE; }
"null"      { update_position(); return NUL; }

[0-9]+\.[0-9]+([eE][-+]?[0-9]+)? { 
    update_position();
    yylval.double_val = atof(yytext);
    return NUMBER;
}

[0-9]+([eE][-+]?[0-9]+)? { 
    update_position();
    yylval.double_val = atof(yytext);
    return NUMBER;
}

\"(\\.|[^\\"])*\" { 
    update_position();
    yylval.string_val = process_string(yytext);
    return STRING;
}

[ \t]       { update_position(); }
[\n]        { new_line(); }
.           { 
    fprintf(stderr, "Error: Unexpected character '%c' at line %d, column %d\n", 
            yytext[0], line, column);
    exit(1);
}
%%

/* Process string, handling escape sequences */
char* process_string(char* text) {
    int len = strlen(text);
    char* result = malloc(len - 1);  /* Remove quotes */
    
    /* Copy characters, handling escapes */
    int j = 0;
    for (int i = 1; i < len - 1; i++) {  /* Skip opening and closing quotes */
        if (text[i] == '\\' && i + 1 < len - 1) {
            i++;
            switch (text[i]) {
                case 'n': result[j++] = '\n'; break;
                case 't': result[j++] = '\t'; break;
                case 'r': result[j++] = '\r'; break;
                case 'b': result[j++] = '\b'; break;
                case 'f': result[j++] = '\f'; break;
                case '\\': result[j++] = '\\'; break;
                case '\"': result[j++] = '\"'; break;
                case 'u': {
                    /* Handle Unicode escapes \uXXXX */
                    if (i + 4 < len - 1) {
                        /* Convert hex to integer - simplified for this example */
                        /* For actual implementation, use proper UTF-8 encoding */
                        i += 4;  /* Skip the 4 hex digits */
                    }
                    break;
                }
                default: result[j++] = text[i];
            }
        } else {
            result[j++] = text[i];
        }
    }
    result[j] = '\0';
    return result;
}